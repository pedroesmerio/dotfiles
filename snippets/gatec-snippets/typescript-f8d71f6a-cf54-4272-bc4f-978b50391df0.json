{
  "Log stringify": {
    "prefix": ["logstrfy"],
    "body": [
      "console.log('$TM_SELECTED_TEXT', JSON.stringify($TM_SELECTED_TEXT, null, 2));"
    ],
    "description": "A console.log for js obj."
  },
  "Criar schemas get": {
    "prefix": "schemaGet",
    "body": [
      "import Realm from 'realm';",
      "import { EBASE_SCHEMA} from './schemas';",
      "",
      "export default class ${TM_SELECTED_TEXT}Schema extends Realm.Object {",
      "  static schema = {",
      "    name: EBASESCHEMA.${TM_SELECTED_TEXT},",
      "    primaryKey: 'Id',",
      "    properties: {",
      "      Id: { type: 'int', indexed: true },",
      "      PARAM_STRING: { type: 'string?' },",
      "      PARAM_ARRAY: { type: 'string[]' },",
      "      PARAM_BOOLEAN: { type: 'bool', default: false },",
      "    },",
      "  };",
      "",
      "  public Id!: number;",
      "",
      "  public PARAM_STRING?: string;",
      "",
      "  public PARAM_ARRAY?: string[];",
      "",
      "  public PARAM_BOOLEAN?: boolean;",
      "}",
      "",
      ""
    ],
    "description": "Criar schemas get"
  },
  "Criar schemas post": {
    "prefix": "schemaPost",
    "body": [
      "import Realm from 'realm';",
      "import { EBASE_SCHEMA} from './schemas';",
      "import { buildSaveDateTime } from 'gaUtils';",
      "",
      "",
      "export default class ${TM_SELECTED_TEXT}Schema extends Realm.Object {",
      "  static schema = {",
      "    name: EBASESCHEMA.${TM_SELECTED_TEXT},",
      "    primaryKey: 'IdMobile',",
      "    properties: {",
      "      IdMobile: { type: 'string' },",
      "      PendingSync: { type: 'bool?', default: false },",
      "      MobUserNameCreator: { type: 'string?' },",
      "      MobUserNameLastChange: { type: 'string?' },",
      "      MobileCreationDate: {",
      "        type: 'string?',",
      "        default: buildSaveDateTime(new Date()),",
      "      },",
      "      MobileLastChangeDate: {",
      "        type: 'string?',",
      "        default: buildSaveDateTime(new Date()),",
      "      },",
      "    },",
      "  };",
      "",
      "  public IdMobile!: string;",
      "",
      "  public PendingSync?: boolean;",
      "",
      "  public MobUserNameCreator?: string;",
      "",
      "  public MobUserNameLastChange?: string;",
      "",
      "  public MobileCreationDate?: string;",
      "",
      "  public MobileLastChangeDate?: string;",
      "}",
      "",
      ""
    ],
    "description": "Criar schemas post"
  },
  "Criar repository get": {
    "prefix": "repoGet",
    "body": [
      "import BaseRepositoryGet from 'infra/base/baseRepositoryGet.class';",
      "import ${TM_SELECTED_TEXT}Schema from 'infra/schemas/SCHEMA_PATH/${TM_SELECTED_TEXT}.schema';",
      "import { ERealm } from 'infra/schemas/Base/schemas';",
      "",
      "export default class ${TM_SELECTED_TEXT}Repository extends BaseRepositoryGet<${TM_SELECTED_TEXT}Schema>{",
      "  constructor() {",
      "    super(ERealm.${TM_SELECTED_TEXT});",
      "  }",
      "}",
      ""
    ],
    "description": "Criar repository get"
  },
  "Criar repository post": {
    "prefix": "repoPost",
    "body": [
      "import getRealm from 'core/realm';",
      "import BaseRepositoryPost from 'infra/base/baseRepositoryPost.class';",
      "import { ERealm } from 'infra/schemas/SCHEMA_PATH/schemas';",
      "import ${TM_SELECTED_TEXT}Schema from 'infra/schemas/SCHEMA_PATH/${TM_SELECTED_TEXT}.schema';",
      "",
      "export default class ${TM_SELECTED_TEXT}Repository extends BaseRepositoryPost<${TM_SELECTED_TEXT}Schema> {",
      "  constructor() {",
      "    super(ERealm.${TM_SELECTED_TEXT});",
      "  }",
      "",
      "  async getForUpload() {",
      "    const realm = await getRealm();",
      "",
      "    const items = realm.objects<${TM_SELECTED_TEXT}Schema>(this.schema);",
      "",
      "    const filtered = items.filtered('PendingSync = true').toJSON();",
      "",
      "    return filtered as ${TM_SELECTED_TEXT}Schema[];",
      "  }",
      "}",
      ""
    ],
    "description": "Criar repository post"
  },
  "Criar service get": {
    "prefix": "servGet",
    "body": [
      "import api from 'core/api';",
      "import { InfraError } from 'infra/base/baseError.class';",
      "import BaseServiceGet from 'infra/base/baseServiceGet.class';",
      "import { IAPIRes, IRequestAPI } from 'infra/base/types';",
      "import ${TM_SELECTED_TEXT}Repository from 'infra/repository/REPOSITORY_PATH\\';",
      "import ${TM_SELECTED_TEXT}Schema from 'infra/schemas/SCHEMA_PATH/${TM_SELECTED_TEXT}.schema';",
      "",
      "const repository = new ${TM_SELECTED_TEXT}Repository();",
      "",
      "export default class ${TM_SELECTED_TEXT}Service extends BaseServiceGet<${TM_SELECTED_TEXT}Schema> {",
      "  constructor() {",
      "    super(repository);",
      "  }",
      "",
      "  async getForSync<ReqType>(requestObject: IRequestAPI<ReqType>) {",
      "    const { data }: { data: IAPIRes<${TM_SELECTED_TEXT}Schema[]> } = await api.post(",
      "      'MobileSync/Get${TM_SELECTED_TEXT}',",
      "      requestObject,",
      "    );",
      "",
      "    if (data.HasError) {",
      "      throw new InfraError(data.Errors.join(','));",
      "    }",
      "",
      "    return data.Data;",
      "  }",
      "}",
      ""
    ],
    "description": "Criar service get"
  },
  "Criar service post": {
    "prefix": "servPost",
    "body": [
      "import api from 'core/api';",
      "import { InfraError } from 'infra/base/baseError.class';",
      "import BaseServicePost from 'infra/base/baseServicePost.class';",
      "import { IAPIRes, IRequestAPI } from 'infra/base/types';",
      "import ${TM_SELECTED_TEXT}Repository from 'infra/repository/REPOSITORY_PATH\\';",
      "import ${TM_SELECTED_TEXT}Schema from 'infra/schemas/SCHEMA_PATH/${TM_SELECTED_TEXT}.schema';",
      "",
      "const repository = new ${TM_SELECTED_TEXT}Repository();",
      "",
      "export default class ${TM_SELECTED_TEXT}Service extends BaseServicePost<${TM_SELECTED_TEXT}Schema> {",
      "  constructor() {",
      "    super(repository);",
      "  }",
      "",
      "  async getForUpload() {",
      "    const entries = await repository.getForUpload();",
      "",
      "    return entries;",
      "  }",
      "",
      "  async setPendingSync(idMobile: string) {",
      "    const entry = await this.getByIdMobile(idMobile);",
      "",
      "    if (entry) {",
      "      const updateItem = JSON.parse(",
      "        JSON.stringify(entry),",
      "      ) as ${TM_SELECTED_TEXT}Schema;",
      "",
      "      updateItem.PendingSync = !updateItem.PendingSync;",
      "",
      "      await this.save(updateItem);",
      "      return true;",
      "    }",
      "",
      "    return false;",
      "  }",
      "",
      "  async sendAll<T>(requestObject: IRequestAPI<T>) {",
      "    const { data }: { data: IAPIRes<${TM_SELECTED_TEXT}Schema[]> } = await api.post(",
      "      'MobileSync/UploadWorkOrders',",
      "      requestObject,",
      "    );",
      "",
      "    if (data.HasError) {",
      "      throw new InfraError(data.Errors.join(','));",
      "    }",
      "",
      "    return data.Data;",
      "  }",
      "}",
      ""
    ],
    "description": "Criar service post"
  },
  "Criar controller get": {
    "prefix": "ctrlGet",
    "body": [
      "import BaseControllerGet from 'infra/base/baseControllerGet.class';",
      "import { IRequestAPI } from 'infra/base/types';",
      "import ${TM_SELECTED_TEXT}Schema from 'infra/schemas/SCHEMA_PATH/${TM_SELECTED_TEXT}.schema';",
      "import ${TM_SELECTED_TEXT}Service from 'infra/services/SERVICE_PATH';",
      "import { getResponseObject } from 'utils';",
      "",
      "const service = new ${TM_SELECTED_TEXT}Service();",
      "",
      "export default class ${TM_SELECTED_TEXT}Controller extends BaseControllerGet<${TM_SELECTED_TEXT}Schema>(",
      "  service,",
      "  '${TM_SELECTED_TEXT}',",
      ") {",
      "  static async getForSync(requestObject: IRequestAPI<any>) {",
      "    try {",
      "      const result = await service.getForSync<any>(requestObject);",
      "",
      "      return getResponseObject(true, result);",
      "    } catch (error) {",
      "      throw await getResponseObject(false, undefined, {",
      "        message: error?.message,",
      "        hierarchy: `${this.name} - getForSync`,",
      "        payload: JSON.stringify(requestObject),",
      "      });",
      "    }",
      "  }",
      "}",
      ""
    ],
    "description": "Criar controller get"
  },
  "Criar controller post": {
    "prefix": "ctrlPost",
    "body": [
      "import BaseControllerPost from 'infra/base/baseControllerPost.class';",
      "import { IRequestAPI } from 'infra/base/types';",
      "import ${TM_SELECTED_TEXT}Schema from 'infra/schemas/WorkOrder/${TM_SELECTED_TEXT}.schema';",
      "import ${TM_SELECTED_TEXT}Service from 'infra/services/WorkOrder/${TM_SELECTED_TEXT}.service';",
      "import { getResponseObject } from 'utils';",
      "",
      "const service = new ${TM_SELECTED_TEXT}Service();",
      "",
      "export default class ${TM_SELECTED_TEXT}Controller extends BaseControllerPost<${TM_SELECTED_TEXT}Schema>(",
      "  service,",
      "  '${TM_SELECTED_TEXT}',",
      ") {",
      "  static async getForUpload() {",
      "    try {",
      "      const result = await service.getForUpload();",
      "",
      "      return getResponseObject<${TM_SELECTED_TEXT}Schema[]>(true, result);",
      "    } catch (error) {",
      "      throw await getResponseObject(false, undefined, {",
      "        message: error?.message,",
      "        hierarchy: `${this.name} - getForUpload`,",
      "      });",
      "    }",
      "  }",
      "",
      "  static async setPendingSync(id: string) {",
      "    try {",
      "      const result = await service.setPendingSync(id);",
      "",
      "      return getResponseObject<boolean>(true, result);",
      "    } catch (error) {",
      "      throw await getResponseObject(false, undefined, {",
      "        message: error?.message,",
      "        hierarchy: `${this.name} - setPendingSync`,",
      "        payload: `${id}`,",
      "      });",
      "    }",
      "  }",
      "",
      "  static async sendAll(requestObject: IRequestAPI<${TM_SELECTED_TEXT}Schema[]>) {",
      "    try {",
      "      const result = await service.sendAll(requestObject);",
      "",
      "      return getResponseObject<any>(true, result);",
      "    } catch (error) {",
      "      throw await getResponseObject(false, undefined, {",
      "        message: error?.message,",
      "        hierarchy: `${this.name} - sendAll`,",
      "        payload: JSON.stringify(requestObject),",
      "      });",
      "    }",
      "  }",
      "}",
      ""
    ],
    "description": "Criar controller post"
  },
  "Criar reducer básico": {
    "prefix": "reduBasic",
    "body": [
      "import { clearErrorsValidation } from 'gaUtils';",
      "",
      "import { ModelSchema } from 'infra/base/types';",
      "import { MobReferenceObjectSchema } from 'infra/schemas/Base';",
      "",
      "export interface Errors {",
      "  [key: string]: string | undefined;",
      "}",
      "",
      "export type StateOptions = {",
      "  OPTION: ModelSchema<SCHEMA_OPTION>[];",
      "  // ? ...Options",
      "};",
      "",
      "export type StateValues = {",
      "  VALUE: ModelSchema<MobReferenceObjectSchema> | undefined;",
      "  // ? ...Values",
      "};",
      "",
      "export interface State {",
      "  options: StateOptions;",
      "  values: StateValues;",
      "  errors: Errors;",
      "  isReady: boolean;",
      "  loading: boolean;",
      "}",
      "",
      "export type SetDataAction = {",
      "  type: 'LOAD_DATA';",
      "  payload: {",
      "    options: StateOptions;",
      "    values: StateValues;",
      "  };",
      "};",
      "",
      "export type SetValuesAction = {",
      "  type: 'SET_VALUES';",
      "  payload: {",
      "    [key in keyof StateValues]?: StateValues[key];",
      "  };",
      "};",
      "",
      "export type SetErrorAction = {",
      "  type: 'SET_ERROR';",
      "  payload: Errors;",
      "};",
      "",
      "export type SetLoading = {",
      "  type: 'SET_LOADING';",
      "  payload: boolean;",
      "};",
      "",
      "export type Action =",
      "  | SetDataAction",
      "  | SetValuesAction",
      "  | SetErrorAction",
      "  | SetLoading;",
      "",
      "export const INITIAL_STATE: State = {",
      "  options: {} as StateOptions,",
      "  values: {} as StateValues,",
      "  errors: {} as Errors,",
      "  isReady: false,",
      "  loading: false,",
      "};",
      "",
      "export const reducer = (state: State, action: Action): State => {",
      "  switch (action.type) {",
      "    case 'LOAD_DATA':",
      "      return { ...state, ...action.payload, isReady: true };",
      "",
      "    case 'SET_VALUES': {",
      "      const result = {",
      "        ...action.payload,",
      "      };",
      "",
      "      const cleanErrors = clearErrorsValidation(result);",
      "",
      "      const errors = { ...state.errors, ...cleanErrors };",
      "",
      "      return {",
      "        ...state,",
      "        values: {",
      "          ...state.values,",
      "          ...result,",
      "        },",
      "        errors,",
      "      };",
      "    }",
      "",
      "    case 'SET_ERROR':",
      "      return {",
      "        ...state,",
      "        errors: { ...state.errors, ...action.payload },",
      "      };",
      "",
      "    case 'SET_LOADING': {",
      "      return { ...state, loading: action.payload };",
      "    }",
      "",
      "    default:",
      "      return { ...state };",
      "  }",
      "};",
      ""
    ],
    "description": "Criar reducer básico"
  }
}
